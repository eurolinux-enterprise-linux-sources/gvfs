From ce9d7700c5641610d1c4c2400c2ab3f9183288fb Mon Sep 17 00:00:00 2001
From: Ross Lagerwall <rosslagerwall@gmail.com>
Date: Sun, 31 Aug 2014 10:29:02 +0100
Subject: [PATCH] archive: Allow reading files with '/./' in the path

Allow reading files with a "." component in the path.  This is a
followup to 46bdbf1d4596 ('archive: Ignore filenames consisting of a
single "."'), which allowed the archive backend to enumerate an archive
with a single "." in the path.

Implement this with a generic function to fixup an archive_entry path,
and use this wherever archive_entry_pathname() is used.

https://bugzilla.gnome.org/show_bug.cgi?id=729463
---
 daemon/gvfsbackendarchive.c | 80 +++++++++++++++++++++++++++++++--------------
 1 file changed, 55 insertions(+), 25 deletions(-)

diff --git a/daemon/gvfsbackendarchive.c b/daemon/gvfsbackendarchive.c
index f98ee78..3720467 100644
--- a/daemon/gvfsbackendarchive.c
+++ b/daemon/gvfsbackendarchive.c
@@ -258,6 +258,44 @@ g_vfs_backend_archive_init (GVfsBackendArchive *archive)
 
 /*** FILE TREE HANDLING ***/
+static char *
+fixup_path (const char *path)
+{
+  char *str, *ptr;
+  int len;
+
+  /* skip leading garbage if present */
+  if (g_str_has_prefix (path, "./"))
+    str = g_strdup (path + 2);
+  else
+    str = g_strdup (path);
+
+  /* strip '/./' from the path */
+  ptr = str;
+  while ((ptr = strstr (ptr, "/./")))
+    {
+      char *dst = ptr + 2;
+      while (*dst)
+        *++ptr = *++dst;
+    }
+
+  /* strip '//' from the path */
+  ptr = str;
+  while ((ptr = strstr (ptr, "//")))
+    {
+      char *dst = ptr + 1;
+      while (*dst)
+        *++ptr = *++dst;
+    }
 
-/* NB: filename must NOT start with a slash */
+  /* strip trailing slash from the path */
+  len = strlen (str);
+  if (len > 0 && str[len - 1] == '/')
+    str[len - 1] = '\0';
+
+  return str;
+}
+
+/* Filename must be a clean path containing no '.' entries, no empty entries
+ * and must not start with a '/'. */
 static ArchiveFile *
 archive_file_get_from_path (ArchiveFile *file, const char *filename, gboolean add)
@@ -268,7 +306,4 @@ archive_file_get_from_path (ArchiveFile *file, const char *filename, gboolean ad
   guint i;
 
-  /* libarchive reports paths starting with ./ for some archive types */
-  if (g_str_has_prefix (filename, "./"))
-    filename += 2;
   names = g_strsplit (filename, "/", -1);
 
@@ -287,17 +322,7 @@ archive_file_get_from_path (ArchiveFile *file, const char *filename, gboolean ad
 	{
 	  DEBUG ("adding node %s to %s\n", names[i], file->name);
-	  if (names[i][0] != 0 &&
-              strcmp (names[i], ".") != 0)
-	    {
-	      cur = g_slice_new0 (ArchiveFile);
-	      cur->name = g_strdup (names[i]);
-	      file->children = g_slist_prepend (file->children, cur);
-	    }
-	  else
-	    {
-	      /* Ignore empty elements from directories ending with a slash.
-	       * Ignore elements consisting of a single "." */
-	      cur = file;
-	    }
+          cur = g_slice_new0 (ArchiveFile);
+          cur->name = g_strdup (names[i]);
+          file->children = g_slist_prepend (file->children, cur);
 	}
       file = cur;
@@ -535,4 +560,7 @@ create_file_tree (GVfsBackendArchive *ba, GVfsJob *job)
       if (result >= ARCHIVE_WARN && result <= ARCHIVE_OK)
 	{
+          ArchiveFile *file;
+          char *path;
+
   	  if (result < ARCHIVE_OK) {
   	    DEBUG ("archive_read_next_header: result = %d, error = '%s'\n", result, archive_error_string (archive->archive));
@@ -543,7 +571,7 @@ create_file_tree (GVfsBackendArchive *ba, GVfsJob *job)
 	  }
   
-	  ArchiveFile *file = archive_file_get_from_path (ba->files, 
-	                                                  archive_entry_pathname (entry), 
-							  TRUE);
+          path = fixup_path (archive_entry_pathname (entry));
+          file = archive_file_get_from_path (ba->files, path, TRUE);
+          g_free (path);
           /* Don't set info for root */
           if (file != ba->files)
@@ -696,5 +724,5 @@ do_open_for_read (GVfsBackend *       backend,
   int result;
   ArchiveFile *file;
-  const char *entry_pathname;
+  char *entry_pathname;
 
   file = archive_file_find (ba, filename);
@@ -731,10 +759,10 @@ do_open_for_read (GVfsBackend *       backend,
 	  }
 
-          entry_pathname = archive_entry_pathname (entry);
-          /* skip leading garbage if present */
-          if (g_str_has_prefix (entry_pathname, "./"))
-            entry_pathname += 2;
+          entry_pathname = fixup_path (archive_entry_pathname (entry));
+
           if (g_str_equal (entry_pathname, filename + 1))
             {
+              g_free (entry_pathname);
+
               /* SUCCESS */
               g_vfs_job_open_for_read_set_handle (job, archive);
@@ -745,4 +773,6 @@ do_open_for_read (GVfsBackend *       backend,
           else
             archive_read_data_skip (archive->archive);
+
+          g_free (entry_pathname);
         }
     }
-- 
2.5.0

