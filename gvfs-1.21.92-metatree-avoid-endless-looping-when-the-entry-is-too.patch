From 46474abab3ff89a34cbe7fd7eb1ceba50d83d331 Mon Sep 17 00:00:00 2001
From: Ondrej Holy <oholy@redhat.com>
Date: Fri, 29 Aug 2014 10:46:25 +0200
Subject: [PATCH] metatree: avoid endless looping when the entry is too large

When an application tries to save a larger key-value pair than the size
of the journal, it triggers the journal to be flushed to make space for
the entry and the operation is then retried, but it never fits, and the
loop continues forever.

This patch removes the endless retry loop and retries the operation
only once after the flush. We know that there isn't enough space for
the entry if it fails after the flush.

https://bugzilla.gnome.org/show_bug.cgi?id=637095
---
 metadata/metatree.c | 65 ++++++++++++++++++++++++++++++++++++-----------------
 1 file changed, 45 insertions(+), 20 deletions(-)

diff --git a/metadata/metatree.c b/metadata/metatree.c
index 43766c8..7b59c4a 100644
--- a/metadata/metatree.c
+++ b/metadata/metatree.c
@@ -2361,13 +2361,18 @@ meta_tree_unset (MetaTree                         *tree,
   entry = meta_journal_entry_new_unset (mtime, path, key);
 
   res = TRUE;
- retry:
   if (!meta_journal_add_entry (tree->journal, entry))
     {
       if (meta_tree_flush_locked (tree))
-	goto retry;
-
-      res = FALSE;
+        {
+	  if (!meta_journal_add_entry (tree->journal, entry))
+	  {
+	    g_warning ("meta_tree_unset: entry is bigger then the size of journal\n");
+	    res = FALSE;
+	  }
+	}
+      else
+        res = FALSE;
     }
 
   g_string_free (entry, TRUE);
@@ -2401,13 +2406,18 @@ meta_tree_set_string (MetaTree                         *tree,
   entry = meta_journal_entry_new_set (mtime, path, key, value);
 
   res = TRUE;
- retry:
   if (!meta_journal_add_entry (tree->journal, entry))
     {
       if (meta_tree_flush_locked (tree))
-	goto retry;
-
-      res = FALSE;
+        {
+	  if (!meta_journal_add_entry (tree->journal, entry))
+	  {
+	    g_warning ("meta_tree_set_string: entry is bigger then the size of journal\n");
+	    res = FALSE;
+	  }
+	}
+      else
+        res = FALSE;
     }
 
   g_string_free (entry, TRUE);
@@ -2441,13 +2451,18 @@ meta_tree_set_stringv (MetaTree                         *tree,
   entry = meta_journal_entry_new_setv (mtime, path, key, value);
 
   res = TRUE;
- retry:
   if (!meta_journal_add_entry (tree->journal, entry))
     {
       if (meta_tree_flush_locked (tree))
-	goto retry;
-
-      res = FALSE;
+        {
+	  if (!meta_journal_add_entry (tree->journal, entry))
+	  {
+	    g_warning ("meta_tree_set_stringv: entry is bigger then the size of journal\n");
+	    res = FALSE;
+	  }
+	}
+      else
+        res = FALSE;
     }
 
   g_string_free (entry, TRUE);
@@ -2479,13 +2494,18 @@ meta_tree_remove (MetaTree *tree,
   entry = meta_journal_entry_new_remove (mtime, path);
 
   res = TRUE;
- retry:
   if (!meta_journal_add_entry (tree->journal, entry))
     {
       if (meta_tree_flush_locked (tree))
-	goto retry;
-
-      res = FALSE;
+        {
+	  if (!meta_journal_add_entry (tree->journal, entry))
+	  {
+	    g_warning ("meta_tree_remove: entry is bigger then the size of journal\n");
+	    res = FALSE;
+	  }
+	}
+      else
+        res = FALSE;
     }
 
   g_string_free (entry, TRUE);
@@ -2518,13 +2538,18 @@ meta_tree_copy (MetaTree                         *tree,
   entry = meta_journal_entry_new_copy (mtime, src, dest);
 
   res = TRUE;
- retry:
   if (!meta_journal_add_entry (tree->journal, entry))
     {
       if (meta_tree_flush_locked (tree))
-	goto retry;
-
-      res = FALSE;
+        {
+	  if (!meta_journal_add_entry (tree->journal, entry))
+	  {
+	    g_warning ("meta_tree_copy: entry is bigger then the size of journal\n");
+	    res = FALSE;
+	  }
+	}
+      else
+        res = FALSE;
     }
 
   g_string_free (entry, TRUE);
-- 
1.9.3

